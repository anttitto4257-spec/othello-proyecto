//Librerias para usar las distintas funciones
#include <stdio.h> 
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define MAX 30 //
#define TAM 8 //Declaración de macro para el tamaño de la matriz 8x8.

//Función para pedir el nombre al o a los jugadores.
void pedirnombre(char nombre[], int numero) {
	printf ("\nPor favor, ingrese el nombre del jugador %d: ",numero);
	scanf ("%s", nombre); //Guardamos el nombre del jugador en la variable nombre
}

//Función para elegir el color.
char elegircolor(char nombre[]) {
	char color; //variable para guardar los colores
	int valido = 0; //inicializamos la variable color

	do {
		printf("\n%s, Elija el color de su ficha (N para el color Negro, B para el color blanco): ", nombre); //jugador elije color
		scanf(" %c", &color); // El espacio antes de %c ignora espacios y saltos previos

		if (color == 'N' || color == 'n' || color == 'B' || color == 'b') { //Acepta los caracteres en mayúscula y minúscula.
			valido = 1;
		} else {
			printf("Error: esa opcion no es valida, por favor ingrese N para negro, B para blanco.\n"); //Error si elige otra opción.
		}

	} while (!valido);

	if (color == 'N' || color == 'n') { 
		return 'N';
	} else {
		return 'B';
	}
}
//Gracias al do - while al escribir algo incorrecto te pide que elijas nuevamente.



//Función para imprimir el tablero en pantalla.
void imprimirTablero(char Tablero[TAM][TAM]) {
	printf("\n  "); //Agregamos espacios para alinear las filas con las columnas.
	for(int j = 0; j < TAM; j++) {
		printf("%2d ", j);  //Declaración de columnas.
	}
	printf("\n"); //espacio 

	for(int i = 0; i < TAM; i++) {
		printf("%2d", i); //Declaración de filas.
		for(int j = 0; j < TAM; j++) {
			printf("%2c ", Tablero[i][j]);//Declaración de columnas dentro de las filas.
		}
		printf("\n");
	}
	printf("\n");
}


//FUNCIONES PARA MOVER LAS FICHAS EN TODAS LAS DIRECCIONES POSIBLES:

// Voltear las fichas hacia arriba
int arriba(char Tablero[TAM][TAM], int f, int c, char color) {
    int fila = f - 1; //Al restar uno se acerca al 0. Declaramos una nueva variable fila para no modificar la original.
    char rival = (color == 'N') ? 'B' : 'N'; //El signo de pregunta funciona como un if
    int capturadas = 0; //Inicializamos la variable capturadas
    while (fila >= 0 && Tablero[fila][c] == rival) { //fila debe ser mayor ó = a 0 para poder moverse dentro de la matriz que comienza en 0
        capturadas++;  
        fila--; //Resta ya que se acerca al 0
    }
    if (fila >= 0 && Tablero[fila][c] == color && capturadas > 0) { //si arriba hay una del mismo color captura
        for (int i = 1; i <= capturadas; i++)
            Tablero[f - i][c] = color;
            return capturadas; //devuelve las fichas capturadas 
    }
    return 0;
}


// Voltear las fichas hacia abajo
int abajo(char Tablero[TAM][TAM], int f, int c, char color) {
    int fila = f + 1; //Al suma uno se acerca al tamaño máximo de la matriz. Declaramos una nueva variable fila para no modificar la original.
    char rival = (color == 'N') ? 'B' : 'N';
    int capturadas = 0;
    while (fila < TAM && Tablero[fila][c] == rival) {
        capturadas++;
        fila++;
    }
    if (fila < TAM && Tablero[fila][c] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
            Tablero[f + i][c] = color;
            return capturadas;
    }
    return 0;
}


//Voltear las fichas hacia la izq
int izq(char Tablero[TAM][TAM], int f, int c, char color) {
     int columna = c - 1; //Al restar uno se acerca al 0. Declaramos una nueva variable columna para no modificar la original.
     char rival = (color == 'N') ? 'B' : 'N';
     int capturadas = 0;
     while (columna >= 0 && Tablero[f][columna] == rival){
        capturadas++;
        columna--;
     }
    if (columna >= 0 && Tablero[f][columna] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
            Tablero[f][c - i] = color;
            return capturadas;
    }
    return 0;
}


//Voltear las fichas hacia la der
int der(char Tablero[TAM][TAM], int f, int c, char color) {
     int columna = c + 1; //Al sumar uno se acerca al tamaño máximo de la matriz. Declaramos una nueva variable columna para no modificar la original.
     char rival = (color == 'N') ? 'B' : 'N';
     int capturadas = 0;
     while (columna < TAM && Tablero[f][columna] == rival){
        capturadas++;
        columna++;
     }
     if (columna < TAM && Tablero[f][columna] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
        Tablero[f][c + i] = color;
     return capturadas;
    }
    return 0;
}

//Continuamos con la misma modalidad pero modificando suma y resta de filas y columnas según que movimiento corresponda:

//Voltear fichas en diagonal arriba para la izq
int arribaizq(char Tablero[TAM][TAM], int f, int c, char color) {
    int fila = f - 1, columna = c - 1;
    char rival = (color == 'N') ? 'B' : 'N';
    int capturadas = 0;
    while (fila >= 0 && columna >= 0 && Tablero[fila][columna] == rival) {
        capturadas++;
        fila--, columna--;
    }
    if (fila >= 0 && columna >=0 && Tablero[fila][columna] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
            Tablero[f - i][c - i] = color;
    return capturadas;
    }
    return 0;
}


//Voltear fichas en diagonal arriba para la der
int arribader(char Tablero[TAM][TAM], int f, int c, char color) {
    int fila = f - 1, columna = c + 1;
    char rival = (color == 'N') ? 'B' : 'N';
    int capturadas = 0;
    while (fila >= 0 && columna < TAM && Tablero[fila][columna] == rival) {
        capturadas++;
        fila--, columna++;
    }
    if (fila >= 0 && columna < TAM && Tablero[fila][columna] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
            Tablero[f - i][c + i] = color;
    return capturadas;
    }
    return 0;
}


//Voltear fichas en diagonal abajo para la izq
int abajoizq(char Tablero[TAM][TAM], int f, int c, char color) {
    int fila = f + 1, columna = c - 1;
    char rival = (color == 'N') ? 'B' : 'N';
    int capturadas = 0;
    while (fila < TAM && columna >= 0 && Tablero[fila][columna] == rival) {
        capturadas++;
        fila++, columna--;
    }
    if (fila < TAM && columna >=0 && Tablero[fila][columna] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
            Tablero[f + i][c - i] = color;
    return capturadas;
    }
    return 0;
}

//Voltear fichas en diagonal abajo para la der
int abajoder(char Tablero[TAM][TAM], int f, int c, char color) {
    int fila = f + 1, columna = c + 1;
    char rival = (color == 'N') ? 'B' : 'N';
    int capturadas = 0;
    while (fila < TAM && columna < TAM && Tablero[fila][columna] == rival) {
        capturadas++;
        fila++, columna++;
    }
    if (fila < TAM && columna < TAM && Tablero[fila][columna] == color && capturadas > 0) {
        for (int i = 1; i <= capturadas; i++)
            Tablero[f + i][c + i] = color;
    return capturadas;
    }
    return 0;
}



//Para capturar fichas.
int puede_capturar(char Tablero[TAM][TAM], int f, int c, char color) { //función para permitir capturar fichas
    if (Tablero[f][c] != '.') return 0; //Si no hay un punto no permite capturar 

    char rival = (color == 'N') ? 'B' : 'N';
    int total = 0; //inicializamos la variable total

    // Para cada dirección [df (dirección-fila), dc (dirección-columna)]

    int dirs[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; //Todas las direcciones posibles
    for (int d = 0; d < 8; d++) { //Inicializamos la variable d (direccion)
        int df = dirs[d][0], dc = dirs[d][1]; //Direccion de fila y columna
        int ff = f + df, cc = c + dc; 
        int count = 0;
        while (ff >=  0 && ff < TAM && cc >= 0 && cc < TAM && Tablero[ff][cc] == rival) { //Cuenta fichas del rival 
            count++; 
            ff += df; //Suma o deja igual según la dirección de la fila
            cc += dc; //Suma o deja igual según la dirección de la columna
        }
        if (count > 0 && ff >= 0 && ff < TAM && cc >= 0 && cc < TAM && Tablero[ff][cc] == color) //Si aparece una del propio color,las fichas del rival están encerradas y las voltea
            total += count;
    }
    return total;
}


// Una jugada es válida si captura al menos una ficha
bool jugadavalida(char Tablero[TAM][TAM], int f, int c, char color) { //dentro estan los parametros de fila columna color
//la funcion bool devuelve un valor logico true o false true (la condición se cumple).
//falso (la condición no se cumple).
    return puede_capturar(Tablero, f, c, color) > 0; //llama a la funcion puede_capturar
	//cuenta las fichas que se deberian dar vuelta si es mas a 1 lo toma como valida si no como movimiento invalido
}

int contar_fichas_capturadas(char Tablero[TAM][TAM], int f, int c, char color) {
    int total = 0;
    total += arriba(Tablero, f, c, color);
    total += abajo(Tablero, f, c, color);
    total += izq(Tablero, f, c, color);
    total += der(Tablero, f, c, color);
    total += arribaizq(Tablero, f, c, color);
    total += arribader(Tablero, f, c, color);
    total += abajoizq(Tablero, f, c, color);
    total += abajoder(Tablero, f, c, color);
    return total;
} //esta funcion int contar fichas devuelve un numero entero que representa cuantas fichas del rival de deberian dar vuelta al colocarlas en la posicion (f,c)
//Cada línea suma lo que capturás en una dirección del tablero y se inicia en 0

//Función para que juegue el jugador.
void jugadajugador(char Tablero[TAM][TAM], char color) {
    int f, c, capturadas = 0;

    do{
        printf("Ingrese fila y columna: ");
        scanf("%d %d", &f, &c); //entrada de datos,deciden donde poner fichas 
        if (!jugadavalida(Tablero, f, c, color)){
            printf("Jugada invalida, debes capturar por lo menos una ficha para continuar.\n");
        } //este if corrobora que la jugada es valida al capturar como menos unna  ficha y lo repite hasta que el jugador escriba una jugada valida
    }while(!jugadavalida(Tablero, f, c, color));

    Tablero[f][c] = color; //pone la ficha del jugador en la cordenada valida

    // --- Aquí llamamos a contar_fichas_capturadas para ver cuántas fichas se capturaron ---
    capturadas += arriba(Tablero, f, c, color);
    capturadas += abajo(Tablero, f, c, color);
    capturadas += izq(Tablero, f, c, color);
    capturadas += der(Tablero, f, c, color);
    capturadas += arribaizq(Tablero, f, c, color);
    capturadas += arribader(Tablero, f, c, color);
    capturadas += abajoizq(Tablero, f, c, color);
    capturadas += abajoder(Tablero, f, c, color);
//funcion que revisa en todas las direcciones las fichas atrapadas del rival 
    if(capturadas > 0){
        printf("¡Capturaste %d fichas en esta jugada!\n", capturadas);
    } else {
        printf("La próxima será maestro, no capturaste ninguna ficha en esta jugada.\n");
    } //mensaje para los jugadores , le avisa cuantas fichas capturo,solo sale cuando capturo +1 , ya que filtramos los movimientos invalidos
} //conclusion de esta funcion La función pide una jugada, verifica si es válida, coloca la ficha, da vuelta las del rival y muestra cuántas se capturaron.


// Igual que arriba, solo muestra el mensaje después de la jugada.
// Lo hacemos solo si el sistema puede jugar (maxCaptura > 0).
void jugadasistema(char Tablero[TAM][TAM], char color) {
    int mejorF = -1, mejorC = -1, maxCaptura = 0;//guarda la fila y colunma de la mejor jugada encontrada y la cantidad maxima de fichas capturadas
    for (int f = 0; f < TAM; f++) { //busca la mejor opcion de jugada , recorriendo todas las casillas del tablero y vacias por supuesto
        for (int c = 0; c < TAM; c++) {
            int captura = puede_capturar(Tablero, f, c, color);
            if (Tablero[f][c] == '.' && captura > maxCaptura) {
                maxCaptura = captura;
                mejorF = f;
                mejorC = c;
            }
        }
    }
    if (maxCaptura > 0) {
        printf("El sistema juega en la posicion: %d %d\n", mejorF, mejorC);
        Tablero[mejorF][mejorC] = color; //cuando encuentra la mejor jugada valida pone la ficha en las cordenadas elejidas 

        int capturadas = 0;//va en toda las direcciones volteando las fichas de la jugada y al final las cuenta
        capturadas += arriba(Tablero, mejorF, mejorC, color);
        capturadas += abajo(Tablero, mejorF, mejorC, color);
        capturadas += izq(Tablero, mejorF, mejorC, color);
        capturadas += der(Tablero, mejorF, mejorC, color);
        capturadas += arribaizq(Tablero, mejorF, mejorC, color);
        capturadas += arribader(Tablero, mejorF, mejorC, color);
        capturadas += abajoizq(Tablero, mejorF, mejorC, color);
        capturadas += abajoder(Tablero, mejorF, mejorC, color);

        if(capturadas > 0){
            printf("El sistema capturó %d fichas en esta jugada.\n", capturadas);
        } else {
            printf("El sistema no capturó ninguna ficha en esta jugada.\n"); //muestra los resultados de capturar +1 ya que esta validada la jugada y filtrado los movimientos invalidos 
        }
    } else {
        printf("El sistema no tiene jugadas validas.\n");
    }//si no encuentra ninguna jugada valida muestra este mensaje por pantalla 
} //conclusion de esta funcion : busca la mejor jugada,coloca la ficha y cuenta cuantas capturo

//Función para sortear el color que comienza en la partida.
char sortearColor() {
    return (rand() % 2 == 0) ? 'N' : 'B'; //numero al azar entre 0 y 1 , 0=n 1=b 
}

//Función para declarar si una jugada es válida.
int tiene_jugada_valida(char Tablero[TAM][TAM], char color) { //recorre todo el tablero 
	for (int i = 0; i < TAM; i++) {
		for (int j = 0; j < TAM; j++) {
			if (Tablero[i][j] == '.' && jugadavalida(Tablero, i, j, color)) {
				return 1; // Verdadero
			}
		}
	}
	return 0; // Falso
}//esta funcion implemeta la regla de pasar turno,si un jugador no tiene movimientos validos tiene que pasar el turno , y si ninguno tiene fichas validas la partida termina 


int main() {

	char jugador1[MAX], jugador2[MAX];
	char color1, color2;
	char colorQueEmpieza;
    char colorSistema = '\0';

    int mododejuego = 1; // 1 = Contra persona, 2 = Contra sistema
    int seguir_jugando = 1;//permite otra partida sin cerra el programa 
//Variables que se usan durante eljuego 
	printf("Bienvenido al Othello!\n");

	printf("\nSeleccione modo de juego:\n");
	printf("\n1. Jugar contra otra persona\n");
	printf("\n2. Jugar contra el sistema\n");
	printf("\nIngrese 1 o 2: ");
	scanf("%d", &mododejuego);

	pedirnombre(jugador1, 1);
//seleccion de los modos de juego 
    if (mododejuego == 1) {
        pedirnombre(jugador2, 2);
    } else {
        char sistema[] = "Sistema";
        int i = 0;
        while (sistema[i] != '\0') {
        jugador2[i] = sistema[i];
        i++;
    }
      jugador2[i] = '\0'; // Fin de cadena
    }



    // eleccion de los colores,Primero se elige el color de cada jugador
    color1 = elegircolor(jugador1);
    color2 = (color1 == 'N') ? 'B' : 'N';

    if (mododejuego == 2) {
        // El sistema siempre es jugador 2 en este código
        colorSistema = color2;
    }

	printf("\nColores asignados :\n");
	printf("Jugador 1: %s (%c)\n", jugador1, color1);
	printf("Jugador 2: %s (%c)\n", jugador2, color2);

	 srand(time(NULL));

    do {
        //INICIO DE LA PARTIDA,tablero vacio y las 4 fichas aleatorias en el centro 
        char Tablero[TAM][TAM];
        for (int i = 0; i < TAM; i++)
            for (int j = 0; j < TAM; j++)
                Tablero[i][j] = '.';

        Tablero[3][3] = 'B'; //Posiciones iniciales de las fichas.
        Tablero[3][4] = 'N';
        Tablero[4][3] = 'B';
        Tablero[4][4] = 'N';

        colorQueEmpieza = sortearColor();//sorteo del color que empieza la partida 


    printf("\n¡Sorteo Listo!\nEl color que comienza es: %c\n", colorQueEmpieza);

    // Se determina qué jugador tiene ese color y cuál comienza.
    if (colorQueEmpieza == color1) {
        printf("Empieza %s\n", jugador1);
    } else {
        printf("Empieza %s\n", jugador2);
    }

	imprimirTablero(Tablero);

    char turno = colorQueEmpieza;  //bucle principal de turnos ,revisa si hay juagada valida , se termina la partida si se saltan los turnos dos veces o si el tablero esta lleno 
    int sin_jugadas_consecutivas = 0;
        while (1) {
            printf("\nTurno de color %c\n", turno);

            if (tiene_jugada_valida(Tablero, turno)) {
                sin_jugadas_consecutivas = 0;
                if (mododejuego == 2 && turno == colorSistema) {
                    jugadasistema(Tablero, turno);
                } else {
                    jugadajugador(Tablero, turno);
                }
                imprimirTablero(Tablero);
            } else {
                printf("El jugador %c no tiene jugadas validas y pasa el turno.\n", turno);
                sin_jugadas_consecutivas++;
            }

            turno = (turno == 'N') ? 'B' : 'N';

            if (sin_jugadas_consecutivas == 2) {
                break;
            }
            int lleno = 1;
            for (int i = 0; i < TAM; i++)
                for (int j = 0; j < TAM; j++)
                    if (Tablero[i][j] == '.') lleno = 0;
            if (lleno) {
                break;
            }
        }
//Cuenta cuántas fichas de cada color quedaron,anuncia el ganador o si hubo empate.
    int cuentaN = 0, cuentaB = 0;
       for (int i = 0; i < TAM; i++)
            for (int j = 0; j < TAM; j++) {
                if (Tablero[i][j] == 'N') cuentaN++;
                if (Tablero[i][j] == 'B') cuentaB++;
            }

        printf("¡Fin del juego!\n");
        printf("Fichas Negras: %d\n", cuentaN); //Cuenta la cantidad de fichas de cada jugador.
        printf("Fichas Blancas: %d\n", cuentaB);

        if (cuentaN > cuentaB)
            printf("¡Gana el jugador de color Negro!\n"); //Determina el ganador.
        else if (cuentaB > cuentaN)
            printf("¡Gana el jugador de color Blanco!\n");
        else
            printf("¡Empate!\n");
        //FIN DE LA PARTIDA
//repeticion de la partida sin cerra el programa ni que se vuelvan a pedir los nombres de los jugadores 
        printf("\n¿Quieres jugar otra vez? (1=Si, 0=No): ");
        scanf("%d", &seguir_jugando);

    } while (seguir_jugando);

    printf("¡Gracias por jugar Othello!\n");
    printf("Presiona Enter para salir...");
    getchar(); // consume salto de línea pendiente
    getchar(); // espera enter
    return 0;

}
//Soporta dos modos de juego.
//Tiene sorteo de inicio.
//Implementa la regla de pasar turno.
//Permite repetir partidas.
//Cuenta fichas y declara el ganador.


